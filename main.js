/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  POMODORO_VIEW_TYPE: () => POMODORO_VIEW_TYPE,
  PomodoroView: () => PomodoroView,
  default: () => PomodoroTaskPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  tag: "#pomodoro",
  workDuration: 25,
  shortBreakDuration: 5,
  longBreakDuration: 15,
  subtaskCount: 3,
  enableSubtaskLimit: true,
  defaultSubtasksExpanded: true,
  autoStartPaused: false,
  showCompletedSubtasks: false,
  showCompletedToday: false,
  volume: 50,
  soundWorkStart: "digital",
  soundWorkEnd: "none",
  soundBreakEnd: "gong",
  soundPause: "bell",
  markerWidgetPos: null,
  enableDebugLogs: false
};
var DebugLogger = class {
  constructor(plugin) {
    this.logs = [];
    this.maxLogs = 100;
    this.plugin = plugin;
  }
  log(...args) {
    if (!this.plugin.settings.enableDebugLogs)
      return;
    const timestamp = new Date().toLocaleTimeString();
    const message = args.map(
      (arg) => typeof arg === "object" ? JSON.stringify(arg) : String(arg)
    ).join(" ");
    const logEntry = `[${timestamp}] ${message}`;
    this.logs.push(logEntry);
    if (this.logs.length > this.maxLogs) {
      this.logs.shift();
    }
    console.log("[PomodoroTask]", ...args);
  }
  getLogs() {
    return this.logs.join("\n");
  }
  clear() {
    this.logs = [];
  }
};
var SoundService = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  play(soundId) {
    if (!soundId || soundId === "none")
      return;
    const volume = this.plugin.settings.volume / 100;
    if (volume === 0)
      return;
    this.playTone(soundId, volume);
  }
  playTone(type, volume) {
    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
    if (!AudioContextClass)
      return;
    const ctx = new AudioContextClass();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.connect(gain);
    gain.connect(ctx.destination);
    const now = ctx.currentTime;
    if (type === "blip") {
      osc.type = "sine";
      osc.frequency.setValueAtTime(800, now);
      osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
      gain.gain.setValueAtTime(volume, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
      osc.start(now);
      osc.stop(now + 0.1);
    } else if (type === "ding") {
      osc.type = "triangle";
      osc.frequency.setValueAtTime(500, now);
      osc.frequency.linearRampToValueAtTime(1e3, now + 0.1);
      gain.gain.setValueAtTime(volume, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.6);
      osc.start(now);
      osc.stop(now + 0.6);
    } else if (type === "chime") {
      osc.type = "sine";
      osc.frequency.setValueAtTime(600, now);
      osc.frequency.linearRampToValueAtTime(400, now + 0.3);
      gain.gain.setValueAtTime(volume, now);
      gain.gain.linearRampToValueAtTime(0.01, now + 1);
      osc.start(now);
      osc.stop(now + 1);
    } else if (type === "click") {
      osc.type = "square";
      osc.frequency.setValueAtTime(150, now);
      gain.gain.setValueAtTime(volume * 0.5, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
      osc.start(now);
      osc.stop(now + 0.05);
    } else if (type === "alarm") {
      const mkBeep = (t) => {
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.connect(g);
        g.connect(ctx.destination);
        o.type = "square";
        o.frequency.value = 880;
        g.gain.setValueAtTime(volume, t);
        g.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
        o.start(t);
        o.stop(t + 0.2);
      };
      mkBeep(now);
      mkBeep(now + 0.3);
      mkBeep(now + 0.6);
    } else if (type === "bell") {
      const pOsc = ctx.createOscillator();
      const pGain = ctx.createGain();
      pOsc.connect(pGain);
      pGain.connect(osc.frequency);
      pOsc.type = "sine";
      pOsc.frequency.value = 440;
      pGain.gain.setValueAtTime(1e3, now);
      pGain.gain.exponentialRampToValueAtTime(1, now + 1.5);
      osc.type = "sine";
      osc.frequency.setValueAtTime(880, now);
      gain.gain.setValueAtTime(volume, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 2);
      osc.start(now);
      pOsc.start(now);
      osc.stop(now + 2);
      pOsc.stop(now + 2);
    } else if (type === "tick") {
      const bufferSize = ctx.sampleRate * 0.05;
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * volume;
      }
      const noise = ctx.createBufferSource();
      noise.buffer = buffer;
      noise.connect(ctx.destination);
      noise.start(now);
    } else if (type === "tock") {
      osc.type = "sine";
      osc.frequency.setValueAtTime(600, now);
      osc.frequency.exponentialRampToValueAtTime(100, now + 0.05);
      gain.gain.setValueAtTime(volume, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
      osc.start(now);
      osc.stop(now + 0.05);
    } else if (type === "wood") {
      osc.type = "sine";
      osc.frequency.setValueAtTime(800, now);
      gain.gain.setValueAtTime(volume, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
      osc.start(now);
      osc.stop(now + 0.1);
    } else if (type === "gong") {
      osc.type = "sine";
      osc.frequency.setValueAtTime(220, now);
      gain.gain.setValueAtTime(volume, now);
      gain.gain.linearRampToValueAtTime(0.01, now + 4);
      osc.start(now);
      osc.stop(now + 4);
      const harm = ctx.createOscillator();
      const hGain = ctx.createGain();
      harm.connect(hGain);
      hGain.connect(ctx.destination);
      harm.frequency.value = 224;
      hGain.gain.setValueAtTime(volume * 0.5, now);
      hGain.gain.linearRampToValueAtTime(0.01, now + 3);
      harm.start(now);
      harm.stop(now + 4);
    } else if (type === "arcade") {
      osc.type = "square";
      osc.frequency.setValueAtTime(220, now);
      osc.frequency.linearRampToValueAtTime(880, now + 0.2);
      gain.gain.setValueAtTime(volume * 0.5, now);
      gain.gain.linearRampToValueAtTime(0.01, now + 0.2);
      osc.start(now);
      osc.stop(now + 0.2);
    } else if (type === "digital") {
      osc.type = "square";
      osc.frequency.setValueAtTime(3e3, now);
      gain.gain.setValueAtTime(volume, now);
      gain.gain.setValueAtTime(0, now + 0.08);
      gain.gain.setValueAtTime(volume, now + 0.16);
      gain.gain.setValueAtTime(0, now + 0.24);
      osc.start(now);
      osc.stop(now + 0.25);
    }
  }
};
var DEFAULT_STATS = {
  completedSessions: 0,
  totalWorkDuration: 0
};
var TimerService = class {
  constructor(plugin) {
    this.state = {
      state: "IDLE",
      startTime: null,
      duration: 0,
      taskId: null,
      taskLine: -1,
      taskFile: "",
      taskText: "",
      completedSubtasks: []
    };
    this.intervalId = null;
    this.plugin = plugin;
    this.soundService = new SoundService(plugin);
  }
  async loadState() {
    const saved = await this.plugin.loadData();
    if (saved && saved.timerState) {
      this.state = saved.timerState;
      if (this.state.state !== "IDLE") {
        this.startTick();
      }
    }
  }
  async saveState() {
    await this.plugin.saveAllData();
  }
  startSession(task, type, overrides) {
    var _a, _b;
    let duration = 0;
    if (type === "WORK") {
      duration = (_a = overrides == null ? void 0 : overrides.workDuration) != null ? _a : this.plugin.settings.workDuration;
    } else {
      duration = (_b = overrides == null ? void 0 : overrides.shortBreakDuration) != null ? _b : this.plugin.settings.shortBreakDuration;
    }
    this.state = {
      state: type,
      startTime: Date.now(),
      duration,
      taskId: task.file.path + ":" + task.line,
      taskLine: task.line,
      taskFile: task.file.path,
      taskText: task.text,
      completedSubtasks: [],
      overrides
    };
    if (type === "WORK") {
      this.soundService.play(this.plugin.settings.soundWorkStart);
    }
    if (this.plugin.settings.autoStartPaused) {
      this.state.pausedTime = Date.now();
    }
    void this.saveState();
    this.startTick();
    void this.plugin.refreshView();
  }
  stopSession() {
    this.clearInterval();
    this.state = {
      state: "IDLE",
      startTime: null,
      duration: 0,
      taskId: null,
      taskLine: -1,
      taskFile: "",
      completedSubtasks: [],
      taskText: "",
      pausedTime: null
    };
    void this.saveState();
    void this.plugin.refreshView();
  }
  pauseSession() {
    if (this.state.state !== "IDLE" && !this.state.pausedTime) {
      this.state.pausedTime = Date.now();
      this.clearInterval();
      this.soundService.play(this.plugin.settings.soundPause);
      void this.saveState();
      void this.plugin.refreshView();
    }
  }
  resumeSession() {
    if (this.state.state !== "IDLE" && this.state.pausedTime && this.state.startTime) {
      const pauseDuration = Date.now() - this.state.pausedTime;
      this.state.startTime += pauseDuration;
      this.state.pausedTime = null;
      void this.saveState();
      this.startTick();
      void this.plugin.refreshView();
    }
  }
  startTick() {
    this.clearInterval();
    if (this.state.pausedTime)
      return;
    this.intervalId = setInterval(() => {
      const timeLeft = this.getTimeLeft();
      if (timeLeft <= 0) {
        void this.completeSession();
      }
      this.plugin.updateTimerUI();
    }, 1e3);
  }
  applyOverrides(work, shortBreak) {
    this.state.overrides = {
      workDuration: work,
      shortBreakDuration: shortBreak
    };
    if (this.state.state === "WORK") {
      this.state.duration = work;
    } else if (this.state.state === "BREAK") {
      this.state.duration = shortBreak;
    }
    void this.saveState();
    void this.plugin.refreshView();
    this.plugin.updateTimerUI();
  }
  resetSession() {
    if (this.state.state !== "IDLE") {
      this.state.startTime = Date.now();
      this.state.pausedTime = null;
      void this.saveState();
      this.startTick();
      void this.plugin.refreshView();
      this.plugin.updateTimerUI();
    }
  }
  switchMode() {
    if (this.state.state !== "IDLE") {
      const nextType = this.state.state === "WORK" ? "BREAK" : "WORK";
      const file = this.plugin.app.vault.getAbstractFileByPath(this.state.taskFile);
      if (file instanceof import_obsidian.TFile) {
        this.startSession({
          file,
          line: this.state.taskLine,
          text: this.state.taskText
        }, nextType, this.state.overrides);
      } else {
        this.stopSession();
      }
    }
  }
  clearInterval() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
  }
  getTimeLeft() {
    if (!this.state.startTime)
      return 0;
    const now = this.state.pausedTime || Date.now();
    const elapsedSec = (now - this.state.startTime) / 1e3;
    const totalSec = this.state.duration * 60;
    return Math.max(0, totalSec - elapsedSec);
  }
  async completeSession() {
    this.clearInterval();
    if (this.state.state === "WORK") {
      this.soundService.play(this.plugin.settings.soundWorkEnd);
      await this.logCompletion();
      this.plugin.stats.completedSessions += 1;
      this.plugin.stats.totalWorkDuration += this.state.duration;
      await this.plugin.saveAllData();
      new import_obsidian.Notice("Pomodoro finished! Time for a break.");
      this.stopSession();
    } else {
      const isLong = this.state.duration >= this.plugin.settings.longBreakDuration;
      if (isLong) {
        this.soundService.play(this.plugin.settings.soundBreakEnd);
      } else {
        this.soundService.play(this.plugin.settings.soundBreakEnd);
      }
      new import_obsidian.Notice("Break finished! Ready to work?");
      this.stopSession();
    }
  }
  async logCompletion() {
    this.plugin.debugLogger.log("logCompletion called");
    const file = this.plugin.app.vault.getAbstractFileByPath(this.state.taskFile);
    if (!(file instanceof import_obsidian.TFile)) {
      this.plugin.debugLogger.log("File not found:", this.state.taskFile);
      return;
    }
    const content = await this.plugin.app.vault.read(file);
    const lines = content.split("\n");
    const lineIdx = this.state.taskLine;
    if (lineIdx >= lines.length) {
      this.plugin.debugLogger.log("Line index out of bounds");
      return;
    }
    let line = lines[lineIdx];
    this.plugin.debugLogger.log("Current line:", line);
    if (!line.includes(this.state.taskText.substring(0, 5))) {
      new import_obsidian.Notice("Task line changed? Could not log time to the exact line.");
      return;
    }
    const tomatoRegex = /(\[)?ðŸ…::\s*(\d+)(?:\s*\/\s*(\d+))?(\])?/;
    const match = line.match(tomatoRegex);
    let newLine = line;
    let shouldComplete = false;
    if (match) {
      const hasOpenBracket = match[1] === "[";
      const hasCloseBracket = match[4] === "]";
      const hasBrackets = hasOpenBracket && hasCloseBracket;
      const currentCount = parseInt(match[2]);
      const goalStr = match[3];
      let goal = null;
      const newCount = currentCount + 1;
      let newLabel = `\u{1F345}:: ${newCount}`;
      if (goalStr) {
        newLabel += `/${goalStr}`;
        goal = parseInt(goalStr);
      }
      if (hasBrackets) {
        newLabel = `[${newLabel}]`;
      }
      this.plugin.debugLogger.log("Counter:", currentCount, "->", newCount, "Goal:", goal, "Brackets:", hasBrackets);
      newLine = line.replace(match[0], newLabel);
      if (goal !== null && newCount >= goal) {
        this.plugin.debugLogger.log("Goal reached! Checking if task should be completed...");
        const checkboxRegex = /^(\s*[-*+]\s*)\[ \]/;
        if (checkboxRegex.test(newLine)) {
          shouldComplete = true;
          this.plugin.debugLogger.log("Task will be completed");
        } else {
          this.plugin.debugLogger.log("Task does not have unchecked checkbox");
        }
      }
    } else {
      newLine = `${line} \u{1F345}:: 1`;
      this.plugin.debugLogger.log("No counter found, starting at 1");
    }
    this.plugin.debugLogger.log("shouldComplete:", shouldComplete);
    if (shouldComplete) {
      this.plugin.debugLogger.log("Calling completeTaskViaTasksAPI");
      await this.completeTaskViaTasksAPI(file, lineIdx, line);
    } else {
      lines[lineIdx] = newLine;
      await this.plugin.app.vault.modify(file, lines.join("\n"));
    }
  }
  async completeTaskViaTasksAPI(file, lineIdx, originalLine) {
    var _a, _b;
    this.plugin.debugLogger.log("Attempting to complete task:", originalLine);
    const tomatoRegex = /(\[)?ðŸ…::\s*(\d+)(?:\s*\/\s*(\d+))?(\])?/;
    const match = originalLine.match(tomatoRegex);
    let lineWithUpdatedCounter = originalLine;
    if (match) {
      const hasOpenBracket = match[1] === "[";
      const hasCloseBracket = match[4] === "]";
      const hasBrackets = hasOpenBracket && hasCloseBracket;
      const currentCount = parseInt(match[2]);
      const goalStr = match[3];
      const newCount = currentCount + 1;
      let newLabel = `\u{1F345}:: ${newCount}`;
      if (goalStr) {
        newLabel += `/${goalStr}`;
      }
      if (hasBrackets) {
        newLabel = `[${newLabel}]`;
      }
      lineWithUpdatedCounter = originalLine.replace(match[0], newLabel);
      this.plugin.debugLogger.log("Bracket format preserved:", hasBrackets);
    }
    this.plugin.debugLogger.log("Line with updated counter:", lineWithUpdatedCounter);
    const tasksPlugin = this.plugin.app.plugins.plugins["obsidian-tasks-plugin"];
    this.plugin.debugLogger.log("Tasks plugin found:", !!tasksPlugin);
    this.plugin.debugLogger.log("Tasks API available:", !!(tasksPlugin == null ? void 0 : tasksPlugin.apiV1));
    this.plugin.debugLogger.log("executeToggleTaskDoneCommand available:", !!((_a = tasksPlugin == null ? void 0 : tasksPlugin.apiV1) == null ? void 0 : _a.executeToggleTaskDoneCommand));
    if ((_b = tasksPlugin == null ? void 0 : tasksPlugin.apiV1) == null ? void 0 : _b.executeToggleTaskDoneCommand) {
      const result = tasksPlugin.apiV1.executeToggleTaskDoneCommand(lineWithUpdatedCounter, file.path);
      this.plugin.debugLogger.log("Tasks API result:", result);
      this.plugin.debugLogger.log("Result different from input:", result !== lineWithUpdatedCounter);
      if (result && result !== lineWithUpdatedCounter) {
        const content2 = await this.plugin.app.vault.read(file);
        const lines2 = content2.split("\n");
        const resultLines = result.split("\n");
        this.plugin.debugLogger.log("Result lines count:", resultLines.length);
        const processedResultLines = resultLines.map((resultLine) => {
          if (/^\s*[-*+]\s*\[ \]/.test(resultLine)) {
            const tomatoMatch = resultLine.match(/(\[)?ðŸ…::\s*(\d+)(?:\s*\/\s*(\d+))?(\])?/);
            if (tomatoMatch && tomatoMatch[3]) {
              const hasOpenBracket = tomatoMatch[1] === "[";
              const hasCloseBracket = tomatoMatch[4] === "]";
              const hasBrackets = hasOpenBracket && hasCloseBracket;
              const goal = tomatoMatch[3];
              let resetLabel = `\u{1F345}:: 0/${goal}`;
              if (hasBrackets) {
                resetLabel = `[${resetLabel}]`;
              }
              this.plugin.debugLogger.log("Resetting new task counter to:", resetLabel);
              return resultLine.replace(tomatoMatch[0], resetLabel);
            }
          }
          return resultLine;
        });
        lines2.splice(lineIdx, 1, ...processedResultLines);
        await this.plugin.app.vault.modify(file, lines2.join("\n"));
        this.plugin.debugLogger.log("File modified successfully via Tasks API");
        return;
      }
    }
    this.plugin.debugLogger.log("Falling back to direct modification...");
    const content = await this.plugin.app.vault.read(file);
    const lines = content.split("\n");
    const checkboxRegex = /^(\s*[-*+]\s*)\[ \]/;
    let completedLine = lineWithUpdatedCounter.replace(checkboxRegex, "$1[x]");
    lines[lineIdx] = completedLine;
    await this.plugin.app.vault.modify(file, lines.join("\n"));
    this.plugin.debugLogger.log("File modified with direct replacement");
  }
};
var CycleConfigModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    var _a, _b;
    super(app);
    this.plugin = plugin;
    const overrides = this.plugin.timerService.state.overrides;
    this.workDuration = (_a = overrides == null ? void 0 : overrides.workDuration) != null ? _a : this.plugin.settings.workDuration;
    this.shortBreakDuration = (_b = overrides == null ? void 0 : overrides.shortBreakDuration) != null ? _b : this.plugin.settings.shortBreakDuration;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h3", { text: "Cycle configuration", attr: { style: "text-align: center; margin-bottom: 20px;" } });
    const container = contentEl.createDiv({ cls: "pomodoro-config-modal-container" });
    this.createConfigSection(container, "Focus duration", this.workDuration, [5, 10, 15, 20, 25, 30, 45, 50, 60], (val) => {
      this.workDuration = val;
    });
    this.createConfigSection(container, "Short break", this.shortBreakDuration, [3, 5, 10, 15, 20], (val) => {
      this.shortBreakDuration = val;
    });
    const footer = contentEl.createDiv({ attr: { style: "margin-top: 20px; display: flex; justify-content: center;" } });
    const applyBtn = footer.createEl("button", { text: "Apply changes", cls: "mod-cta pomodoro-apply-btn" });
    applyBtn.onclick = () => {
      this.plugin.timerService.applyOverrides(this.workDuration, this.shortBreakDuration);
      this.close();
    };
  }
  createConfigSection(container, label, initialValue, presets, onChange) {
    const section = container.createDiv({ cls: "pomodoro-config-section" });
    section.createDiv({ cls: "pomodoro-config-label", text: label });
    const inputRow = section.createDiv({ cls: "pomodoro-input-row" });
    const input = inputRow.createEl("input", { type: "number", cls: "pomodoro-time-input" });
    input.value = String(initialValue);
    inputRow.createSpan({ text: "minutes", cls: "pomodoro-unit" });
    input.onchange = () => {
      const val = Number(input.value);
      if (!isNaN(val) && val > 0) {
        onChange(val);
        section.querySelectorAll(".pomodoro-preset-chip").forEach((el) => el.removeClass("is-active"));
      }
    };
    const presetsRow = section.createDiv({ cls: "pomodoro-presets-row" });
    presets.forEach((val) => {
      const chip = presetsRow.createEl("span", { text: String(val), cls: "pomodoro-preset-chip" });
      if (val === initialValue)
        chip.addClass("is-active");
      chip.onclick = () => {
        onChange(val);
        input.value = String(val);
        section.querySelectorAll(".pomodoro-preset-chip").forEach((el) => el.removeClass("is-active"));
        chip.addClass("is-active");
      };
    });
  }
  addDurationChips(container, presets, onClick) {
    const chipContainer = container.createDiv({ cls: "pomodoro-duration-chips" });
    container.setCssProps({ flexWrap: "wrap" });
    presets.forEach((val) => {
      const chip = chipContainer.createEl("button", { text: String(val), cls: "pomodoro-chip" });
      chip.onclick = () => onClick(val);
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var POMODORO_VIEW_TYPE = "pomodoro-view";
var PomodoroView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.floatingStats = null;
    this.currentZoom = 1;
    this.renderCounter = 0;
    this.markdownComponents = [];
    // Floating Marker State
    this.markerWidgetExpanded = false;
    this.isRenderingMarkers = false;
    // Track which markers are in "follow" mode (by name)
    this.markerFollowMode = /* @__PURE__ */ new Set();
    this.scrollHandler = null;
    this.rainbowColors = [
      "#FF6B6B",
      "#4ECDC4",
      "#45B7D1",
      "#96CEB4",
      "#FFEEAD",
      "#D4A5A5",
      "#9B59B6",
      "#3498DB",
      "#E67E22",
      "#2ECC71"
    ];
    this.plugin = plugin;
    this.showSubtasks = this.plugin.settings.defaultSubtasksExpanded;
  }
  getViewType() {
    return POMODORO_VIEW_TYPE;
  }
  getDisplayText() {
    return "Pomodoro task";
  }
  async onOpen() {
    this.contentEl.addEventListener("wheel", (evt) => {
      if (evt.ctrlKey) {
        evt.preventDefault();
        const delta = evt.deltaY > 0 ? -0.1 : 0.1;
        this.currentZoom = Math.min(Math.max(0.5, this.currentZoom + delta), 2.5);
        this.contentEl.style.zoom = this.currentZoom;
      }
    }, { passive: false });
    if (this.floatingStats) {
      this.floatingStats.remove();
      this.floatingStats = null;
    }
    return Promise.resolve();
  }
  clearMarkdownComponents() {
    this.markdownComponents.forEach((c) => {
      this.removeChild(c);
      c.unload();
    });
    this.markdownComponents = [];
  }
  async onClose() {
    this.clearMarkdownComponents();
    if (this.floatingStats) {
      this.floatingStats.remove();
      this.floatingStats = null;
    }
    const markerWidget = document.querySelector(".pomodoro-marker-widget");
    if (markerWidget) {
      markerWidget.remove();
    }
    this.markerFollowMode.clear();
    this.removeScrollHandler();
    return Promise.resolve();
  }
  removeScrollHandler() {
    if (this.scrollHandler) {
      document.removeEventListener("scroll", this.scrollHandler, true);
      this.scrollHandler = null;
    }
  }
  cleanTaskText(text) {
    if (!text)
      return "";
    let clean = text;
    const placeHolders = [];
    clean = clean.replace(/(`+)([\s\S]*?)\1/g, (match) => {
      placeHolders.push(match);
      return `__CODE_${placeHolders.length - 1}__`;
    });
    clean = clean.replace(/\[?ðŸ…::\s*(\d+)(?:\s*\/\s*(\d+))?\]?/g, "");
    clean = clean.replace(/#[\p{L}\p{N}_/-]+/gu, "");
    clean = clean.replace(/\[[^\]]+::.*?\]/g, "");
    clean = clean.replace(/ðŸ”\s*every\s+[^ðŸ“…â³ðŸ›«âœ…âž•ðŸðŸ”ºâ«ðŸ”½#[]+/giu, "");
    clean = clean.replace(/ðŸ\s*delete/giu, "");
    clean = clean.replace(/[ðŸ“…â³ðŸ›«âœ…âž•]\s*\d{4}-\d{2}-\d{2}/gu, "");
    clean = clean.replace(/[ðŸ”ºâ«ðŸ”½]/gu, "");
    clean = clean.replace(/[ðŸ”ðŸðŸ“…â³ðŸ›«âœ…âž•]/gu, "");
    clean = clean.replace(/\s+/g, " ").trim();
    clean = clean.replace(/__CODE_(\d+)__/g, (match, idStr) => {
      const id = parseInt(idStr);
      return placeHolders[id] || match;
    });
    return clean;
  }
  cleanTaskTextForHover(text) {
    if (!text)
      return "";
    let clean = text;
    const placeHolders = [];
    clean = clean.replace(/(`+)([\s\S]*?)\1/g, (match) => {
      placeHolders.push(match);
      return `__CODE_${placeHolders.length - 1}__`;
    });
    clean = clean.replace(/\[?ðŸ…::\s*(\d+)(?:\s*\/\s*(\d+))?\]?/g, "");
    clean = clean.replace(/#[\p{L}\p{N}_/-]+/gu, "");
    clean = clean.replace(/\[[^\]]+::.*?\]/g, "");
    clean = clean.replace(/\s+/g, " ").trim();
    clean = clean.replace(/__CODE_(\d+)__/g, (match, idStr) => {
      const id = parseInt(idStr);
      return placeHolders[id] || match;
    });
    return clean;
  }
  render() {
    this.renderCounter++;
    const currentRenderId = this.renderCounter;
    if (!this.containerEl)
      return;
    const container = this.containerEl.children[1];
    if (!container)
      return;
    const { state } = this.plugin.timerService;
    const hasTimerView = container.querySelector(".pomodoro-timer-view");
    if (state.state !== "IDLE" && hasTimerView) {
      this.updateTimer(container);
      void this.renderMarkers(container);
    } else {
      if (state.state === "IDLE" && this.floatingStats) {
        this.floatingStats.remove();
        this.floatingStats = null;
      }
      this.clearMarkdownComponents();
      container.empty();
      container.addClass("pomodoro-view-container");
      if (state.state !== "IDLE") {
        void this.renderTimer(container);
        void this.renderMarkers(container);
      } else {
        this.renderStats(container);
        void this.renderTaskList(container, currentRenderId);
      }
    }
  }
  async renderMarkers(container) {
    if (this.isRenderingMarkers)
      return;
    this.isRenderingMarkers = true;
    try {
      const parent = document.body;
      const allWidgets = parent.querySelectorAll(".pomodoro-marker-widget");
      if (allWidgets.length > 1) {
        for (let i = 1; i < allWidgets.length; i++) {
          allWidgets[i].remove();
        }
      }
      let file = this.plugin.app.workspace.getActiveFile();
      if (!file && this.plugin.timerService.state.taskFile) {
        const abstractFile = this.plugin.app.vault.getAbstractFileByPath(this.plugin.timerService.state.taskFile);
        if (abstractFile instanceof import_obsidian.TFile) {
          file = abstractFile;
        }
      }
      if (!file) {
        const existing = parent.querySelector(".pomodoro-marker-widget");
        if (existing)
          existing.remove();
        return;
      }
      let widget = parent.querySelector(".pomodoro-marker-widget");
      if (!widget) {
        widget = parent.createDiv({ cls: "pomodoro-marker-widget" });
        const savedPos = this.plugin.settings.markerWidgetPos;
        if (savedPos) {
          widget.setCssProps({
            "--pomodoro-widget-right": "auto",
            "--pomodoro-widget-bottom": "auto",
            "--pomodoro-widget-left": savedPos.x + "px",
            "--pomodoro-widget-top": savedPos.y + "px"
          });
        }
        const header = widget.createDiv({ cls: "pomodoro-marker-header" });
        let isDragging = false;
        let startX = 0;
        let startY = 0;
        let initialLeft = 0;
        let initialTop = 0;
        let hasMoved = false;
        header.onmousedown = (e) => {
          isDragging = true;
          hasMoved = false;
          startX = e.clientX;
          startY = e.clientY;
          const rect = widget.getBoundingClientRect();
          initialLeft = rect.left;
          initialTop = rect.top;
          widget.setCssProps({
            "--pomodoro-widget-right": "auto",
            "--pomodoro-widget-bottom": "auto",
            "--pomodoro-widget-left": initialLeft + "px",
            "--pomodoro-widget-top": initialTop + "px"
          });
          document.addEventListener("mousemove", onMouseMove);
          document.addEventListener("mouseup", handleMouseUp);
          e.preventDefault();
        };
        const onMouseMove = (e) => {
          if (!isDragging)
            return;
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;
          if (Math.abs(dx) > 3 || Math.abs(dy) > 3)
            hasMoved = true;
          widget.setCssProps({
            "--pomodoro-widget-left": initialLeft + dx + "px",
            "--pomodoro-widget-top": initialTop + dy + "px"
          });
        };
        const onMouseUp = async () => {
          if (!isDragging)
            return;
          isDragging = false;
          document.removeEventListener("mousemove", onMouseMove);
          document.removeEventListener("mouseup", handleMouseUp);
          const rect = widget.getBoundingClientRect();
          this.plugin.settings.markerWidgetPos = { x: rect.left, y: rect.top };
          await this.plugin.saveAllData();
        };
        const handleMouseUp = () => {
          void onMouseUp();
        };
        header.onclick = (e) => {
          e.stopPropagation();
          if (!hasMoved) {
            this.markerWidgetExpanded = !this.markerWidgetExpanded;
            if (!this.markerWidgetExpanded) {
              this.resetFollowModeOnCollapse();
            }
            void this.renderMarkers(container);
          }
        };
        header.title = "Drag to move \u2022 click to toggle";
        header.addClass("pomodoro-draggable");
        header.createDiv({ cls: "pomodoro-marker-icon", text: "\u{1F3F7}\uFE0F" });
        header.createDiv({ cls: "pomodoro-marker-title", text: "Markers" });
        widget.createDiv({ cls: "pomodoro-marker-content" });
      }
      if (this.markerWidgetExpanded) {
        widget.addClass("is-expanded");
      } else {
        widget.removeClass("is-expanded");
      }
      const allContentAreas = widget.querySelectorAll(".pomodoro-marker-content");
      if (allContentAreas.length > 1) {
        for (let i = 1; i < allContentAreas.length; i++) {
          allContentAreas[i].remove();
        }
      }
      const contentArea = widget.querySelector(".pomodoro-marker-content");
      if (contentArea) {
        contentArea.empty();
        const fileContent = await this.plugin.app.vault.read(file);
        const lines = fileContent.split("\n");
        const markers = [];
        const markerRegex = /<!-- Marker: (.*?) -->/;
        lines.forEach((line, idx) => {
          const match = line.match(markerRegex);
          if (match) {
            markers.push({ line: idx, name: match[1] || "Unnamed" });
          }
        });
        const list = contentArea.createDiv({ cls: "pomodoro-marker-list" });
        if (markers.length === 0) {
          list.createDiv({ text: "No markers", attr: { style: "font-size: 0.8em; color: var(--text-muted); text-align: center;" } });
        }
        const currentFile = file;
        markers.forEach((m, i) => {
          const color = this.rainbowColors[i % this.rainbowColors.length];
          const item = list.createDiv({ cls: "pomodoro-marker-item" });
          item.style.backgroundColor = color;
          const nameSpan = item.createSpan({ text: m.name, cls: "pomodoro-marker-item-name" });
          nameSpan.onclick = async () => {
            const freshLine = await this.findMarkerLine(currentFile, m.name);
            if (freshLine !== -1) {
              void this.jumpToTask(currentFile.path, freshLine);
            } else {
              new import_obsidian.Notice("Marker not found (deleted?)");
              void this.renderMarkers(container);
            }
          };
          const isFollowing = this.markerFollowMode.has(m.name);
          const followBtn = item.createSpan({
            cls: "pomodoro-marker-follow",
            text: isFollowing ? "\u2192" : "\u{1F4CC}"
          });
          followBtn.title = isFollowing ? "Following window (click to pin)" : "Pinned (click to follow window)";
          followBtn.onclick = (e) => {
            e.stopPropagation();
            if (this.markerFollowMode.has(m.name)) {
              this.markerFollowMode.delete(m.name);
            } else {
              this.markerFollowMode.add(m.name);
            }
            this.setupScrollHandler(currentFile, container);
            void this.renderMarkers(container);
          };
          const editBtn = item.createSpan({ cls: "pomodoro-marker-edit", text: "\u270E" });
          editBtn.onclick = async (e) => {
            e.stopPropagation();
            const freshLine = await this.findMarkerLine(currentFile, m.name);
            if (freshLine !== -1) {
              new RenameModal(this.plugin.app, m.name, (newName) => {
                if (newName && newName !== m.name) {
                  void this.renameMarker(currentFile, freshLine, m.name, newName);
                }
              }).open();
            } else {
              new import_obsidian.Notice("Marker not found.");
              void this.renderMarkers(container);
            }
          };
          const delBtn = item.createSpan({ cls: "pomodoro-marker-delete", text: "\u2716" });
          delBtn.onclick = async (e) => {
            e.stopPropagation();
            const freshLine = await this.findMarkerLine(currentFile, m.name);
            if (freshLine !== -1) {
              await this.deleteMarker(currentFile, freshLine);
            }
          };
        });
        this.setupScrollHandler(currentFile, container);
        const addBtn = contentArea.createDiv({ cls: "pomodoro-marker-add-btn" });
        addBtn.createSpan({ text: "\u2795" });
        addBtn.createSpan({ text: " Add marker here" });
        addBtn.onclick = async (e) => {
          e.stopPropagation();
          const parentWidget = addBtn.closest(".pomodoro-marker-widget");
          const widgetHeader = parentWidget == null ? void 0 : parentWidget.querySelector(".pomodoro-marker-header");
          if (!widgetHeader)
            return;
          const headerRect = widgetHeader.getBoundingClientRect();
          const targetY = headerRect.top + headerRect.height / 2;
          let targetLeaf;
          this.plugin.app.workspace.iterateAllLeaves((leaf) => {
            if (leaf.view instanceof import_obsidian.MarkdownView && leaf.view.file && leaf.view.file.path === currentFile.path) {
              targetLeaf = leaf;
            }
          });
          if (!targetLeaf) {
            new import_obsidian.Notice("File is not open in any editor.");
            return;
          }
          const view = targetLeaf.view;
          if (view.getMode() !== "source") {
            new import_obsidian.Notice("Please switch to editing mode (live preview or source) to add markers contextually.");
            return;
          }
          const contentRect = view.contentEl.getBoundingClientRect();
          const cmEditor = view.editor.cm;
          let detectedPos = null;
          if (cmEditor && parentWidget instanceof HTMLElement) {
            parentWidget.addClass("pomodoro-hidden");
            try {
              const xCandidates = [
                contentRect.left + contentRect.width * 0.1 + 20,
                contentRect.left + contentRect.width * 0.5,
                contentRect.right - 50
              ];
              const yOffsets = [0, 8, -8, 16, -16];
              outerLoop:
                for (const dy of yOffsets) {
                  const safeY = Math.max(contentRect.top + 5, Math.min(targetY + dy, contentRect.bottom - 5));
                  for (const x of xCandidates) {
                    const pos = cmEditor.posAtCoords({ x, y: safeY });
                    if (pos !== null && pos !== void 0) {
                      const line = cmEditor.state.doc.lineAt(pos);
                      detectedPos = { line: line.number - 1 };
                      break outerLoop;
                    }
                  }
                }
            } catch (err) {
              console.warn("Marker hit-test failed:", err);
            } finally {
              parentWidget.removeClass("pomodoro-hidden");
            }
          }
          let calculatedLine = -1;
          if (detectedPos) {
            calculatedLine = detectedPos.line;
          } else {
            new import_obsidian.Notice("Could not align with text line. Try moving the widget closer to the text.");
            return;
          }
          if (calculatedLine === -1) {
            new import_obsidian.Notice("Could not determine line position. Is the widget aligned with text?");
            return;
          }
          await this.addMarker(currentFile, calculatedLine);
        };
      }
    } finally {
      this.isRenderingMarkers = false;
    }
  }
  async findMarkerLine(file, name) {
    const content = await this.plugin.app.vault.read(file);
    const lines = content.split("\n");
    const target = `<!-- Marker: ${name} -->`;
    return lines.findIndex((line) => line.includes(target));
  }
  async addMarker(file, overrideLine = -1) {
    let targetLeaf = null;
    this.plugin.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view instanceof import_obsidian.MarkdownView && leaf.view.file && leaf.view.file.path === file.path) {
        targetLeaf = leaf;
      }
    });
    const content = await this.plugin.app.vault.read(file);
    const lines = content.split("\n");
    const name = `Mark-${Math.floor(Math.random() * 900) + 100}`;
    const markerText = `<!-- Marker: ${name} -->`;
    let insertLine = -1;
    if (overrideLine !== -1) {
      insertLine = overrideLine;
      if (insertLine < 0)
        insertLine = 0;
      if (insertLine > lines.length)
        insertLine = lines.length;
    } else if (targetLeaf) {
      const view = targetLeaf.view;
      const cursor = view.editor.getCursor();
      insertLine = cursor.line;
    } else {
      insertLine = lines.length;
    }
    lines.splice(insertLine, 0, markerText);
    await this.plugin.app.vault.modify(file, lines.join("\n"));
    new import_obsidian.Notice(`Added ${name} at line ${insertLine + 1}`);
    setTimeout(() => this.render(), 100);
  }
  async deleteMarker(file, lineIdx) {
    const content = await this.plugin.app.vault.read(file);
    const lines = content.split("\n");
    if (lines.length > lineIdx) {
      lines.splice(lineIdx, 1);
      await this.plugin.app.vault.modify(file, lines.join("\n"));
      this.render();
    }
  }
  async renameMarker(file, lineIdx, oldName, newName) {
    const content = await this.plugin.app.vault.read(file);
    const lines = content.split("\n");
    if (lines.length > lineIdx) {
      const markerRegex = new RegExp(`<!-- Marker: ${oldName.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")} -->`);
      if (markerRegex.test(lines[lineIdx])) {
        lines[lineIdx] = `<!-- Marker: ${newName} -->`;
        await this.plugin.app.vault.modify(file, lines.join("\n"));
        new import_obsidian.Notice(`Renamed to ${newName}`);
        this.render();
      } else {
        new import_obsidian.Notice("Marker moved or changed, please refresh.");
        this.render();
      }
    }
  }
  // ---- MARKER FOLLOW MODE ----
  setupScrollHandler(file, container) {
    this.removeScrollHandler();
    if (this.markerFollowMode.size === 0) {
      return;
    }
    let isMovingMarker = false;
    let scrollTimeout = null;
    this.scrollHandler = () => {
      if (scrollTimeout) {
        window.clearTimeout(scrollTimeout);
      }
      scrollTimeout = window.setTimeout(() => {
        if (isMovingMarker)
          return;
        isMovingMarker = true;
        void this.moveFollowingMarkers(file, container).finally(() => {
          isMovingMarker = false;
        });
      }, 100);
    };
    document.addEventListener("scroll", this.scrollHandler, true);
  }
  async moveFollowingMarkers(file, container) {
    if (this.markerFollowMode.size === 0)
      return;
    const widget = document.querySelector(".pomodoro-marker-widget");
    if (!widget)
      return;
    const widgetHeader = widget.querySelector(".pomodoro-marker-header");
    if (!widgetHeader)
      return;
    const headerRect = widgetHeader.getBoundingClientRect();
    const targetY = headerRect.top + headerRect.height / 2;
    let targetLeaf;
    this.plugin.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view instanceof import_obsidian.MarkdownView && leaf.view.file && leaf.view.file.path === file.path) {
        targetLeaf = leaf;
      }
    });
    if (!targetLeaf)
      return;
    const view = targetLeaf.view;
    if (view.getMode() !== "source")
      return;
    const contentRect = view.contentEl.getBoundingClientRect();
    const cmEditor = view.editor.cm;
    if (!cmEditor)
      return;
    let detectedLine = -1;
    const widgetEl = widget;
    widgetEl.addClass("pomodoro-hidden");
    try {
      const xCandidates = [
        contentRect.left + contentRect.width * 0.1 + 20,
        contentRect.left + contentRect.width * 0.5,
        contentRect.right - 50
      ];
      const yOffsets = [0, 8, -8, 16, -16];
      outerLoop:
        for (const dy of yOffsets) {
          const safeY = Math.max(contentRect.top + 5, Math.min(targetY + dy, contentRect.bottom - 5));
          for (const x of xCandidates) {
            const pos = cmEditor.posAtCoords({ x, y: safeY });
            if (pos !== null && pos !== void 0) {
              const line = cmEditor.state.doc.lineAt(pos);
              detectedLine = line.number - 1;
              break outerLoop;
            }
          }
        }
    } finally {
      widgetEl.removeClass("pomodoro-hidden");
    }
    if (detectedLine === -1)
      return;
    const content = await this.plugin.app.vault.read(file);
    const lines = content.split("\n");
    detectedLine = this.findValidLineOutsideScriptBlock(lines, detectedLine);
    for (const markerName of this.markerFollowMode) {
      await this.moveMarkerToLine(file, markerName, detectedLine, lines);
    }
  }
  findValidLineOutsideScriptBlock(lines, targetLine) {
    let inScriptBlock = false;
    let scriptBlockStart = -1;
    let scriptBlockEnd = -1;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      if (!inScriptBlock && line.match(/^```/)) {
        inScriptBlock = true;
        scriptBlockStart = i;
      } else if (inScriptBlock && line === "```") {
        scriptBlockEnd = i;
        if (targetLine >= scriptBlockStart && targetLine <= scriptBlockEnd) {
          return Math.min(scriptBlockEnd + 1, lines.length - 1);
        }
        inScriptBlock = false;
        scriptBlockStart = -1;
      }
    }
    if (inScriptBlock && targetLine >= scriptBlockStart) {
      return lines.length - 1;
    }
    return targetLine;
  }
  async moveMarkerToLine(file, markerName, targetLine, currentLines) {
    const content = currentLines ? currentLines.join("\n") : await this.plugin.app.vault.read(file);
    const lines = currentLines || content.split("\n");
    const markerComment = `<!-- Marker: ${markerName} -->`;
    const currentLine = lines.findIndex((line) => line.includes(markerComment));
    if (currentLine === -1) {
      this.markerFollowMode.delete(markerName);
      return;
    }
    if (currentLine === targetLine || Math.abs(currentLine - targetLine) <= 1) {
      return;
    }
    const markerText = lines[currentLine];
    lines.splice(currentLine, 1);
    let adjustedTarget = targetLine;
    if (currentLine < targetLine) {
      adjustedTarget = targetLine - 1;
    }
    adjustedTarget = Math.max(0, Math.min(adjustedTarget, lines.length));
    lines.splice(adjustedTarget, 0, markerText);
    await this.plugin.app.vault.modify(file, lines.join("\n"));
  }
  // Reset follow mode when widget is collapsed
  resetFollowModeOnCollapse() {
    this.markerFollowMode.clear();
    this.removeScrollHandler();
  }
  updateTimer(container) {
    const { state } = this.plugin.timerService;
    const label = container.querySelector(".pomodoro-active-task-label");
    if (label) {
      if (state.pausedTime) {
        label.innerText = "\u23F8\uFE0F paused";
        label.addClass("pomodoro-label-paused");
      } else {
        label.innerText = state.state === "WORK" ? "\u26A0\uFE0F Focusing on" : "\u2615 Taking a break";
        label.removeClass("pomodoro-label-paused");
      }
    }
    const toggle = container.querySelector(".pomodoro-subtask-toggle");
    if (toggle && state.state === "WORK") {
      toggle.textContent = this.showSubtasks ? "\u25BC" : "\u25B6";
    }
    const controls = container.querySelector(".pomodoro-controls");
    if (controls) {
      controls.empty();
      if (state.pausedTime) {
        const resumeBtn = controls.createEl("button", { cls: "pomodoro-btn pomodoro-btn-resume", text: "\u25B6 resume" });
        resumeBtn.onclick = () => this.plugin.timerService.resumeSession();
      } else {
        const pauseBtn = controls.createEl("button", { cls: "pomodoro-btn pomodoro-btn-pause", text: "\u23F8 pause" });
        pauseBtn.onclick = () => this.plugin.timerService.pauseSession();
      }
      const stopBtn = controls.createEl("button", { cls: "pomodoro-btn pomodoro-btn-stop", text: "Stop / cancel" });
      stopBtn.onclick = () => this.plugin.timerService.stopSession();
    }
    const cycleInfo = container.querySelector(".pomodoro-cycle-info");
    if (cycleInfo) {
      void this.populateCycleInfo(cycleInfo);
    }
    const view = container.querySelector(".pomodoro-timer-view");
    const existingList = container.querySelector(".pomodoro-subtask-list");
    const existingMsg = container.querySelector(".pomodoro-no-subtasks");
    if (state.state === "WORK" && this.showSubtasks) {
      void this.renderSubtasks(view);
    } else {
      if (existingList)
        existingList.remove();
      if (existingMsg)
        existingMsg.remove();
    }
  }
  renderTimer(container) {
    const { state } = this.plugin.timerService;
    const view = container.createDiv({ cls: "pomodoro-timer-view" });
    const navBar = view.createDiv({ cls: "pomodoro-timer-nav pomodoro-timer-navbar" });
    const backBtn = navBar.createEl("button", { cls: "clickable-icon pomodoro-back-btn pomodoro-transparent-btn" });
    (0, import_obsidian.setIcon)(backBtn, "arrow-left");
    backBtn.ariaLabel = "Return to task list";
    backBtn.onclick = () => this.plugin.timerService.stopSession();
    const topControls = navBar.createDiv({ cls: "pomodoro-stats-items-container" });
    const settingsBtn = topControls.createEl("button", { cls: "clickable-icon pomodoro-transparent-btn pomodoro-muted-btn" });
    (0, import_obsidian.setIcon)(settingsBtn, "settings");
    settingsBtn.ariaLabel = "Settings";
    settingsBtn.onclick = (e) => {
      e.stopPropagation();
      this.plugin.app.setting.open();
      this.plugin.app.setting.openTabById(this.plugin.manifest.id);
    };
    const refreshBtn = topControls.createEl("button", { cls: "clickable-icon pomodoro-transparent-btn pomodoro-muted-btn" });
    (0, import_obsidian.setIcon)(refreshBtn, "refresh-cw");
    refreshBtn.ariaLabel = "Refresh";
    refreshBtn.onclick = (e) => {
      e.stopPropagation();
      this.render();
    };
    const taskCard = view.createDiv({ cls: "pomodoro-active-task-card" });
    const header = taskCard.createDiv({ cls: "pomodoro-active-task-header pomodoro-draggable pomodoro-stats-row" });
    const label = header.createDiv({ cls: "pomodoro-active-task-label" });
    if (state.pausedTime) {
      label.innerText = "\u23F8\uFE0F paused";
      label.addClass("pomodoro-label-paused");
    } else {
      label.innerText = state.state === "WORK" ? "\u26A0\uFE0F Focusing on" : "\u2615 Taking a break";
    }
    const headerControls = header.createDiv({ cls: "pomodoro-stats-items-container" });
    if (state.state === "WORK") {
      headerControls.createDiv({ text: this.showSubtasks ? "\u25BC" : "\u25B6", cls: "pomodoro-subtask-toggle pomodoro-toggle-icon" });
    }
    header.onclick = () => {
      if (state.state === "WORK") {
        this.showSubtasks = !this.showSubtasks;
        this.render();
      }
    };
    const textContainer = taskCard.createDiv({ cls: "pomodoro-active-task-text-container pomodoro-text-container-row" });
    const cleanedText = this.cleanTaskText(state.taskText);
    const textDiv = textContainer.createDiv({ cls: "pomodoro-active-task-text pomodoro-hidden" });
    const textComp = new import_obsidian.Component();
    this.addChild(textComp);
    this.markdownComponents.push(textComp);
    const hasDataviewScript = /`\$=/.test(cleanedText);
    void import_obsidian.MarkdownRenderer.render(this.plugin.app, cleanedText, textDiv, state.taskFile, textComp).then(() => {
      if (!hasDataviewScript) {
        textDiv.removeClass("pomodoro-hidden");
        return;
      }
      const observer = new MutationObserver(() => {
        const text = textDiv.textContent || "";
        const stillHasRawCode = text.includes("$=") || text.includes("dv.");
        if (!stillHasRawCode) {
          textDiv.removeClass("pomodoro-hidden");
          observer.disconnect();
        }
      });
      observer.observe(textDiv, {
        childList: true,
        subtree: true,
        characterData: true
      });
      setTimeout(() => {
        textDiv.removeClass("pomodoro-hidden");
        observer.disconnect();
      }, 3e3);
    });
    const linkBtn = textContainer.createEl("button", { cls: "pomodoro-link-btn clickable-icon", text: "\u{1F517}" });
    linkBtn.title = "Go to task";
    linkBtn.onclick = (e) => {
      e.stopPropagation();
      void this.jumpToTask(state.taskFile, state.taskLine);
    };
    const timeLeft = this.plugin.timerService.getTimeLeft();
    const minutes = Math.floor(timeLeft / 60);
    const seconds = Math.floor(timeLeft % 60);
    const timeStr = `${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
    view.createDiv({ cls: "pomodoro-timer-display", text: timeStr });
    const cycleInfoContainer = view.createDiv({ cls: "pomodoro-cycle-info" });
    void this.populateCycleInfo(cycleInfoContainer);
    const controls = view.createDiv({ cls: "pomodoro-controls" });
    if (state.pausedTime) {
      const resumeBtn = controls.createEl("button", { cls: "pomodoro-btn pomodoro-btn-resume", text: "\u25B6 resume" });
      resumeBtn.onclick = () => this.plugin.timerService.resumeSession();
    } else {
      const pauseBtn = controls.createEl("button", { cls: "pomodoro-btn pomodoro-btn-pause", text: "\u23F8 pause" });
      pauseBtn.onclick = () => this.plugin.timerService.pauseSession();
    }
    const stopBtn = controls.createEl("button", { cls: "pomodoro-btn pomodoro-btn-stop", text: "Stop" });
    stopBtn.onclick = () => this.plugin.timerService.stopSession();
    const extraControls = view.createDiv({ cls: "pomodoro-controls-extra", attr: { style: "margin-top: 10px; display: flex; gap: 10px;" } });
    const resetBtn = extraControls.createEl("button", { cls: "pomodoro-btn pomodoro-small-btn", text: "Reset" });
    resetBtn.onclick = () => this.plugin.timerService.resetSession();
    const switchBtn = extraControls.createEl("button", { cls: "pomodoro-btn pomodoro-small-btn", text: "Switch" });
    switchBtn.onclick = () => this.plugin.timerService.switchMode();
    const cycleBtn = extraControls.createEl("button", { cls: "pomodoro-btn pomodoro-small-btn", text: "Cycle" });
    cycleBtn.onclick = () => new CycleConfigModal(this.plugin.app, this.plugin).open();
    if (state.state === "WORK" && this.showSubtasks) {
      void this.renderSubtasks(view);
    }
  }
  async populateCycleInfo(cycleDiv) {
    cycleDiv.empty();
    const { state } = this.plugin.timerService;
    const iconSpan = cycleDiv.createSpan();
    iconSpan.innerText = "\u{1F345}";
    const valueSpan = cycleDiv.createSpan({ cls: "pomodoro-cycle-value" });
    if (!state.taskFile) {
      valueSpan.innerText = "--";
      return;
    }
    const file = this.plugin.app.vault.getAbstractFileByPath(state.taskFile);
    if (!(file instanceof import_obsidian.TFile)) {
      valueSpan.innerText = "--";
      return;
    }
    const content = await this.plugin.app.vault.read(file);
    const lines = content.split("\n");
    const lineIdx = state.taskLine;
    if (lineIdx >= lines.length) {
      valueSpan.innerText = "--";
      return;
    }
    const line = lines[lineIdx];
    const tomatoRegex = /\[?ðŸ…::\s*(\d+)(?:\s*\/\s*(\d+))?\]?/;
    const match = line.match(tomatoRegex);
    if (match) {
      const currentCount = parseInt(match[1]);
      const goalStr = match[2];
      if (goalStr) {
        valueSpan.innerText = `${currentCount}/${goalStr}`;
      } else {
        valueSpan.innerText = `${currentCount}`;
      }
    } else {
      valueSpan.innerText = "--";
      valueSpan.addClass("pomodoro-clickable-value");
      valueSpan.title = "Click to set pomodoro goal";
      valueSpan.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.enableCycleEditing(valueSpan, file, lineIdx);
      };
    }
  }
  enableCycleEditing(container, file, lineIdx) {
    container.empty();
    const input = container.createEl("input", { type: "number", cls: "pomodoro-cycle-input" });
    input.onclick = (e) => e.stopPropagation();
    const finish = async () => {
      const val = parseInt(input.value);
      if (!isNaN(val) && val > 0) {
        await this.updateTaskCycleGoal(file, lineIdx, val);
      }
      this.render();
    };
    input.onblur = () => finish();
    input.onkeydown = (e) => {
      if (e.key === "Enter") {
        input.blur();
      }
      if (e.key === "Escape") {
        this.render();
      }
    };
    setTimeout(() => input.focus(), 0);
  }
  async updateTaskCycleGoal(file, lineIdx, goal) {
    const content = await this.plugin.app.vault.read(file);
    const lines = content.split("\n");
    if (lineIdx < lines.length) {
      let line = lines[lineIdx];
      const tomatoRegex = /\[?ðŸ…::\s*(\d+)(?:\s*\/\s*(\d+))?\]?/;
      if (!tomatoRegex.test(line)) {
        const checkboxRegex = /^(\s*[-*+]\s*\[.\]\s*)/;
        const match = line.match(checkboxRegex);
        if (match) {
          const prefix = match[1];
          const rest = line.substring(prefix.length);
          lines[lineIdx] = `${prefix}\u{1F345}:: 0/${goal} ${rest}`;
        } else {
          const indentMatch = line.match(/^(\s*)(.*)/);
          if (indentMatch) {
            const indent = indentMatch[1];
            const text = indentMatch[2];
            lines[lineIdx] = `${indent}\u{1F345}:: 0/${goal} ${text}`;
          } else {
            lines[lineIdx] = `\u{1F345}:: 0/${goal} ${line}`;
          }
        }
        await this.plugin.app.vault.modify(file, lines.join("\n"));
        new import_obsidian.Notice(`Set Pomodoro goal: ${goal}`);
      }
    }
  }
  async renderTaskList(container, renderId) {
    if (renderId !== this.renderCounter)
      return;
    if (!container)
      return;
    const header = container.createDiv({ cls: "pomodoro-header pomodoro-task-list-header" });
    header.createEl("h4", { text: "\u{1F3AF} active tasks" });
    const controls = header.createDiv({ cls: "pomodoro-stats-items-container" });
    const settingsBtn = controls.createEl("button", { cls: "clickable-icon pomodoro-flex-btn" });
    settingsBtn.ariaLabel = "Settings";
    (0, import_obsidian.setIcon)(settingsBtn, "settings");
    settingsBtn.onclick = () => {
      this.plugin.app.setting.open();
      this.plugin.app.setting.openTabById(this.plugin.manifest.id);
    };
    const refreshBtn = controls.createEl("button", { cls: "clickable-icon pomodoro-flex-btn" });
    refreshBtn.ariaLabel = "Refresh list";
    (0, import_obsidian.setIcon)(refreshBtn, "refresh-cw");
    refreshBtn.onclick = () => void this.render();
    let file = this.plugin.app.workspace.getActiveFile();
    if (!file) {
      const view = this.plugin.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (view)
        file = view.file;
    }
    if (!file) {
      if (renderId !== this.renderCounter)
        return;
      container.createEl("p", {
        text: "Open a Markdown file to see tasks.",
        attr: { style: "color: var(--text-muted); font-style: italic; margin-top: 20px;" }
      });
      return;
    }
    const content = await this.plugin.app.vault.read(file);
    if (renderId !== this.renderCounter)
      return;
    const lines = content.split("\n");
    const tasks = [];
    const tag = this.plugin.settings.tag.trim();
    const taskRegex = /^\s*[-*] \[ \]/;
    lines.forEach((line, index) => {
      if (taskRegex.test(line) && line.includes(tag)) {
        tasks.push({
          line: index,
          text: line.replace(taskRegex, "").replace(tag, "").trim()
        });
      }
    });
    if (tasks.length === 0) {
      if (renderId !== this.renderCounter)
        return;
      container.createEl("p", {
        text: `No tasks found with tag ${tag}`,
        attr: { style: "color: var(--text-muted); font-style: italic; margin-top: 20px;" }
      });
      return;
    }
    if (renderId !== this.renderCounter)
      return;
    const list = container.createDiv({ cls: "pomodoro-task-list" });
    tasks.forEach((task) => {
      const item = list.createDiv({ cls: "pomodoro-task-item" });
      const tomatoRegex = /\[?ðŸ…::\s*(\d+)(?:\s*\/\s*(\d+))?\]?/;
      const match = task.text.match(tomatoRegex);
      let tomatoCount = "";
      if (match) {
        const current = match[1];
        const goal = match[2];
        tomatoCount = goal ? `\u{1F345} ${current}/${goal}` : `\u{1F345} ${current}`;
      }
      const cleanText = this.cleanTaskText(task.text);
      const leftSide = item.createDiv({ cls: "pomodoro-task-left" });
      if (tomatoCount) {
        leftSide.createSpan({ cls: "pomodoro-task-count-pill", text: tomatoCount });
      } else {
        const icon = leftSide.createDiv({ cls: "pomodoro-task-icon" });
        (0, import_obsidian.setIcon)(icon, "circle");
      }
      const textContainer = item.createDiv({ cls: "pomodoro-task-text-container" });
      const cleanSpan = textContainer.createDiv({ cls: "pomodoro-task-text-clean pomodoro-hidden" });
      const cleanComp = new import_obsidian.Component();
      this.addChild(cleanComp);
      this.markdownComponents.push(cleanComp);
      const hasDataviewScript = /`\$=/.test(cleanText);
      void import_obsidian.MarkdownRenderer.render(this.plugin.app, cleanText, cleanSpan, file.path, cleanComp).then(() => {
        if (!hasDataviewScript) {
          cleanSpan.removeClass("pomodoro-hidden");
          return;
        }
        const observer = new MutationObserver(() => {
          const text = cleanSpan.textContent || "";
          const stillHasRawCode = text.includes("$=") || text.includes("dv.");
          if (!stillHasRawCode) {
            cleanSpan.removeClass("pomodoro-hidden");
            observer.disconnect();
          }
        });
        observer.observe(cleanSpan, {
          childList: true,
          subtree: true,
          characterData: true
        });
        setTimeout(() => {
          cleanSpan.removeClass("pomodoro-hidden");
          observer.disconnect();
        }, 3e3);
      });
      const hoverText = this.cleanTaskTextForHover(task.text);
      const fullSpan = textContainer.createDiv({ cls: "pomodoro-task-text-full pomodoro-hidden" });
      const hoverComp = new import_obsidian.Component();
      this.addChild(hoverComp);
      this.markdownComponents.push(hoverComp);
      const hoverHasDataview = /`\$=/.test(hoverText);
      void import_obsidian.MarkdownRenderer.render(this.plugin.app, hoverText, fullSpan, file.path, hoverComp).then(() => {
        if (!hoverHasDataview) {
          fullSpan.removeClass("pomodoro-hidden");
          return;
        }
        const observer = new MutationObserver(() => {
          const text = fullSpan.textContent || "";
          const stillHasRawCode = text.includes("$=") || text.includes("dv.");
          if (!stillHasRawCode) {
            fullSpan.removeClass("pomodoro-hidden");
            observer.disconnect();
          }
        });
        observer.observe(fullSpan, {
          childList: true,
          subtree: true,
          characterData: true
        });
        setTimeout(() => {
          fullSpan.removeClass("pomodoro-hidden");
          observer.disconnect();
        }, 3e3);
      });
      item.addEventListener("click", () => {
        this.plugin.timerService.startSession({ file, line: task.line, text: task.text }, "WORK");
      });
    });
  }
  async renderSubtasks(container) {
    const { state } = this.plugin.timerService;
    if (!state.taskFile)
      return;
    const file = this.plugin.app.vault.getAbstractFileByPath(state.taskFile);
    if (!(file instanceof import_obsidian.TFile))
      return;
    const content = await this.plugin.app.vault.read(file);
    const lines = content.split("\n");
    const tag = this.plugin.settings.tag.trim();
    const limit = this.plugin.settings.subtaskCount;
    const useLimit = this.plugin.settings.enableSubtaskLimit;
    const showCompleted = this.plugin.settings.showCompletedSubtasks;
    const showTodayBypass = this.plugin.settings.showCompletedToday;
    const todayStr = (0, import_obsidian.moment)().format("YYYY-MM-DD");
    let currentTaskLine = state.taskLine;
    const cleanTaskText = state.taskText.substring(0, 15);
    if (currentTaskLine >= lines.length || !lines[currentTaskLine].includes(cleanTaskText)) {
      for (let i = 0; i < lines.length; i++) {
        if (lines[i].includes(cleanTaskText) && lines[i].includes(tag)) {
          currentTaskLine = i;
          break;
        }
      }
    }
    const uncheckedCandidates = [];
    const checkedCandidates = [];
    const taskRegex = /^\s*[-*] \[ \]/;
    const completedRegex = /^\s*[-*] \[x\]/i;
    for (let i = currentTaskLine + 1; i < lines.length; i++) {
      const line = lines[i];
      const isTaskLine = taskRegex.test(line);
      const isCompletedLine = completedRegex.test(line);
      if ((isTaskLine || isCompletedLine) && line.includes(tag)) {
        break;
      }
      if (isTaskLine) {
        uncheckedCandidates.push({
          line: i,
          text: line.replace(taskRegex, "").trim(),
          completed: false,
          isSession: false,
          isToday: false
        });
      } else if (isCompletedLine) {
        const text = line.replace(completedRegex, "").trim();
        const isSession = state.completedSubtasks.some((stored) => text.includes(stored));
        const isToday = isSession || line.includes(todayStr);
        checkedCandidates.push({
          line: i,
          text,
          completed: true,
          isSession,
          isToday
        });
      }
    }
    const finalTasks = [];
    let slots = useLimit ? limit : 9999;
    for (const task of uncheckedCandidates) {
      if (slots > 0) {
        finalTasks.push(task);
        slots--;
      }
    }
    for (const task of checkedCandidates) {
      const shouldShow = showCompleted || task.isSession;
      if (shouldShow) {
        const bypassLimit = showTodayBypass && task.isToday || task.isSession;
        if (bypassLimit) {
          finalTasks.push(task);
        } else if (slots > 0) {
          finalTasks.push(task);
          slots--;
        }
      }
    }
    const totalPending = uncheckedCandidates.length;
    const totalSubtasks = uncheckedCandidates.length + checkedCandidates.length;
    if (!this.floatingStats) {
      this.floatingStats = createDiv({ cls: "pomodoro-floating-stats" });
      document.body.appendChild(this.floatingStats);
    }
    this.floatingStats.empty();
    const iconSpan = this.floatingStats.createSpan({ cls: "pomodoro-floating-icon" });
    (0, import_obsidian.setIcon)(iconSpan, "check-circle-2");
    const textSpan = this.floatingStats.createSpan();
    textSpan.innerText = `${totalPending} / ${totalSubtasks}`;
    const oldList = container.querySelector(".pomodoro-subtask-list");
    const oldMsg = container.querySelector(".pomodoro-no-subtasks");
    const oldStats = container.querySelector(".pomodoro-subtask-stats");
    if (oldStats)
      oldStats.remove();
    if (finalTasks.length === 0) {
      container.createDiv({
        text: "No pending subtasks found below.",
        cls: "pomodoro-no-subtasks",
        attr: { style: "text-align: center; color: var(--text-muted); font-size: 0.9em; margin-top: 10px;" }
      });
      if (oldList)
        oldList.remove();
      if (oldMsg)
        oldMsg.remove();
      return;
    }
    const listDiv = container.createDiv({ cls: "pomodoro-subtask-list" });
    finalTasks.forEach((task) => {
      const row = listDiv.createDiv({ cls: "pomodoro-subtask-row pomodoro-subtask-row-flex" });
      const checkbox = row.createEl("input", { type: "checkbox" });
      checkbox.checked = task.completed;
      checkbox.onchange = async () => {
        await this.toggleSubtask(file, task.line, task.text, checkbox.checked);
      };
      const textDiv = row.createDiv({ cls: "pomodoro-subtask-text pomodoro-hidden" });
      const textComp = new import_obsidian.Component();
      this.addChild(textComp);
      this.markdownComponents.push(textComp);
      const hasDataviewScript = /`\$=/.test(task.text);
      void import_obsidian.MarkdownRenderer.render(this.plugin.app, task.text, textDiv, file.path, textComp).then(() => {
        if (!hasDataviewScript) {
          textDiv.removeClass("pomodoro-hidden");
          return;
        }
        const observer = new MutationObserver(() => {
          const text = textDiv.textContent || "";
          const stillHasRawCode = text.includes("$=") || text.includes("dv.");
          if (!stillHasRawCode) {
            textDiv.removeClass("pomodoro-hidden");
            observer.disconnect();
          }
        });
        observer.observe(textDiv, {
          childList: true,
          subtree: true,
          characterData: true
        });
        setTimeout(() => {
          textDiv.removeClass("pomodoro-hidden");
          observer.disconnect();
        }, 3e3);
      });
      if (task.completed) {
        textDiv.addClass("pomodoro-task-completed");
      }
      const linkIcon = row.createSpan({ text: "\u{1F517}", cls: "pomodoro-subtask-link" });
      linkIcon.title = "Jump to subtask";
      linkIcon.onclick = () => this.jumpToTask(state.taskFile, task.line);
    });
    if (oldList)
      oldList.remove();
    if (oldMsg)
      oldMsg.remove();
  }
  async toggleSubtask(file, lineIdx, text, checked) {
    const content = await this.plugin.app.vault.read(file);
    const lines = content.split("\n");
    if (lines.length <= lineIdx)
      return;
    let line = lines[lineIdx];
    if (checked) {
      line = line.replace("[ ]", "[x]");
      this.plugin.timerService.state.completedSubtasks.push(text);
    } else {
      line = line.replace("[x]", "[ ]").replace("[X]", "[ ]");
      this.plugin.timerService.state.completedSubtasks = this.plugin.timerService.state.completedSubtasks.filter((t) => t !== text);
    }
    lines[lineIdx] = line;
    await this.plugin.app.vault.modify(file, lines.join("\n"));
    await this.plugin.timerService.saveState();
    this.render();
  }
  async jumpToTask(filePath, line) {
    const file = this.plugin.app.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian.TFile) {
      const leaf = this.plugin.app.workspace.getLeaf(false);
      await leaf.openFile(file);
      const view = leaf.view;
      if (view && view.editor) {
        view.editor.setCursor({ line, ch: 0 });
        view.editor.scrollIntoView({ from: { line, ch: 0 }, to: { line, ch: 0 } }, true);
        view.editor.focus();
      }
    }
  }
  renderStats(container) {
    const stats = this.plugin.stats;
    const statsDiv = container.createDiv({ cls: "pomodoro-stats" });
    const stat1 = statsDiv.createDiv({ cls: "pomodoro-stat-item" });
    stat1.createSpan({ text: "Cycles", attr: { style: "font-size: 0.8em; opacity: 0.7;" } });
    stat1.createSpan({ cls: "pomodoro-stat-value", text: String(stats.completedSessions) });
    const stat2 = statsDiv.createDiv({ cls: "pomodoro-stat-item" });
    stat2.createSpan({ text: "Focus time", attr: { style: "font-size: 0.8em; opacity: 0.7;" } });
    stat2.createSpan({ cls: "pomodoro-stat-value", text: `${stats.totalWorkDuration} m` });
  }
};
var PomodoroTaskPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.debugLogger = new DebugLogger(this);
    if (!this.stats)
      this.stats = { ...DEFAULT_STATS };
    this.timerService = new TimerService(this);
    await this.timerService.loadState();
    this.registerView(
      POMODORO_VIEW_TYPE,
      (leaf) => new PomodoroView(leaf, this)
    );
    this.addRibbonIcon("alarm-clock", "Pomodoro task", (evt) => {
      void this.activateView();
    });
    this.addCommand({
      id: "open-pomodoro-view",
      name: "Open view",
      callback: () => {
        void this.activateView();
      }
    });
    this.addSettingTab(new PomodoroSettingTab(this.app, this));
    this.registerEvent(this.app.workspace.on("file-open", () => void this.refreshView()));
    this.registerEvent(this.app.workspace.on("active-leaf-change", () => void this.refreshView()));
    this.registerEvent(this.app.vault.on("modify", (file) => {
      const activeFile = this.app.workspace.getActiveFile();
      if (activeFile && file.path === activeFile.path) {
        this.refreshView();
      }
    }));
  }
  refreshView() {
    const leaves = this.app.workspace.getLeavesOfType(POMODORO_VIEW_TYPE);
    leaves.forEach((leaf) => {
      if (leaf.view instanceof PomodoroView) {
        leaf.view.render();
      }
    });
  }
  updateTimerUI() {
    const leaves = this.app.workspace.getLeavesOfType(POMODORO_VIEW_TYPE);
    leaves.forEach((leaf) => {
      if (leaf.view instanceof PomodoroView && this.timerService.state.state !== "IDLE") {
        const display = leaf.view.containerEl.querySelector(".pomodoro-timer-display");
        if (display) {
          const timeLeft = this.timerService.getTimeLeft();
          const minutes = Math.floor(timeLeft / 60);
          const seconds = Math.floor(timeLeft % 60);
          display.textContent = `${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
        } else {
          leaf.view.render();
        }
      }
    });
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(POMODORO_VIEW_TYPE);
    if (leaves.length > 0) {
      leaf = leaves[0];
      void workspace.revealLeaf(leaf);
    } else {
      const rightLeaf = workspace.getRightLeaf(false);
      if (rightLeaf) {
        await rightLeaf.setViewState({ type: POMODORO_VIEW_TYPE, active: true });
        void workspace.revealLeaf(rightLeaf);
      }
    }
  }
  onunload() {
    this.timerService.clearInterval();
  }
  async loadSettings() {
    const loadedData = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, loadedData);
    this.stats = Object.assign({}, DEFAULT_STATS, loadedData ? loadedData.stats : null);
  }
  async saveAllData() {
    const data = {
      ...this.settings,
      stats: this.stats,
      timerState: this.timerService.state
    };
    await this.saveData(data);
  }
};
var PomodoroSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  addDurationChips(container, presets, onClick) {
    const chipContainer = container.createDiv({ cls: "pomodoro-duration-chips" });
    presets.forEach((val) => {
      const chip = chipContainer.createEl("span", { text: String(val), cls: "pomodoro-chip" });
      chip.onclick = () => onClick(val);
    });
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Pomodoro").setHeading();
    new import_obsidian.Setting(containerEl).setName("Target tag").setDesc("Tasks with this tag will appear in the pomodoro panel").addText((text) => text.setPlaceholder("#pomodoro").setValue(this.plugin.settings.tag).onChange(async (value) => {
      this.plugin.settings.tag = value;
      await this.plugin.saveAllData();
    }));
    new import_obsidian.Setting(containerEl).setName("Durations (minutes)").setHeading();
    const workSetting = new import_obsidian.Setting(containerEl).setName("Work duration").setDesc("How long is a focus session?").addText((text) => text.setPlaceholder("25").setValue(String(this.plugin.settings.workDuration)).onChange(async (value) => {
      this.plugin.settings.workDuration = Number(value);
      await this.plugin.saveAllData();
    }));
    this.addDurationChips(containerEl, [1, 5, 10, 15, 20, 25, 30, 45, 60], (val) => {
      this.plugin.settings.workDuration = val;
      const input = workSetting.controlEl.querySelector("input");
      if (input)
        input.value = String(val);
      void this.plugin.saveAllData();
    });
    const shortBreakSetting = new import_obsidian.Setting(containerEl).setName("Short break").setDesc("Duration of a short break").addText((text) => text.setPlaceholder("5").setValue(String(this.plugin.settings.shortBreakDuration)).onChange(async (value) => {
      this.plugin.settings.shortBreakDuration = Number(value);
      await this.plugin.saveAllData();
    }));
    this.addDurationChips(containerEl, [1, 2, 3, 5, 10, 15], (val) => {
      this.plugin.settings.shortBreakDuration = val;
      const input = shortBreakSetting.controlEl.querySelector("input");
      if (input)
        input.value = String(val);
      void this.plugin.saveAllData();
    });
    const longBreakSetting = new import_obsidian.Setting(containerEl).setName("Long break").setDesc("Duration of a long break").addText((text) => text.setPlaceholder("15").setValue(String(this.plugin.settings.longBreakDuration)).onChange(async (value) => {
      this.plugin.settings.longBreakDuration = Number(value);
      await this.plugin.saveAllData();
    }));
    this.addDurationChips(containerEl, [10, 15, 20, 25, 30, 45, 60], (val) => {
      this.plugin.settings.longBreakDuration = val;
      const input = longBreakSetting.controlEl.querySelector("input");
      if (input)
        input.value = String(val);
      void this.plugin.saveAllData();
    });
    new import_obsidian.Setting(containerEl).setName("Start cycle paused").setDesc("If enabled, new sessions will start in a paused state, waiting for you to click resume.").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoStartPaused).onChange(async (value) => {
      this.plugin.settings.autoStartPaused = value;
      await this.plugin.saveAllData();
    }));
    new import_obsidian.Setting(containerEl).setName("Default subtasks expanded").setDesc("Should subtasks be visible by default when starting a task?").addToggle((toggle) => toggle.setValue(this.plugin.settings.defaultSubtasksExpanded).onChange(async (value) => {
      this.plugin.settings.defaultSubtasksExpanded = value;
      await this.plugin.saveAllData();
    }));
    new import_obsidian.Setting(containerEl).setName("Limit subtasks shown").setDesc("Toggle to limit the number of subtasks displayed in the view").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableSubtaskLimit).onChange(async (value) => {
      this.plugin.settings.enableSubtaskLimit = value;
      await this.plugin.saveAllData();
      if (value) {
        countSetting.settingEl.removeClass("pomodoro-hidden");
        todaySetting.settingEl.removeClass("pomodoro-hidden");
      } else {
        countSetting.settingEl.addClass("pomodoro-hidden");
        todaySetting.settingEl.addClass("pomodoro-hidden");
      }
    }));
    const countSetting = new import_obsidian.Setting(containerEl).setName("Max subtasks").setDesc("Maximum number of subtasks to show").addText((text) => text.setPlaceholder("3").setValue(String(this.plugin.settings.subtaskCount)).onChange(async (value) => {
      this.plugin.settings.subtaskCount = Number(value);
      await this.plugin.saveAllData();
    }));
    new import_obsidian.Setting(containerEl).setName("Show completed subtasks").setDesc("If enabled, completed subtasks will be displayed after pending ones").addToggle((toggle) => toggle.setValue(this.plugin.settings.showCompletedSubtasks).onChange(async (value) => {
      this.plugin.settings.showCompletedSubtasks = value;
      await this.plugin.saveAllData();
    }));
    const todaySetting = new import_obsidian.Setting(containerEl).setName("Always show completed today").setDesc("If enabled, tasks completed today will be shown even if the limit is exceeded").addToggle((toggle) => toggle.setValue(this.plugin.settings.showCompletedToday).onChange(async (value) => {
      this.plugin.settings.showCompletedToday = value;
      await this.plugin.saveAllData();
    }));
    if (!this.plugin.settings.enableSubtaskLimit) {
      countSetting.settingEl.addClass("pomodoro-hidden");
      todaySetting.settingEl.addClass("pomodoro-hidden");
    }
    new import_obsidian.Setting(containerEl).setName("Statistics").setHeading();
    new import_obsidian.Setting(containerEl).setName("Reset statistics").setDesc("Resets the total cycles and focus time counters.").addButton((button) => button.setButtonText("Reset stats").setWarning().onClick(async () => {
      this.plugin.stats = {
        completedSessions: 0,
        totalWorkDuration: 0
      };
      await this.plugin.saveAllData();
      void this.plugin.refreshView();
      new import_obsidian.Notice("Pomodoro statistics have been reset.");
    }));
    new import_obsidian.Setting(containerEl).setName("Sounds & notifications").setHeading();
    new import_obsidian.Setting(containerEl).setName("Volume").setDesc("Global volume for all sounds (0-100)").addSlider((slider) => slider.setLimits(0, 100, 5).setValue(this.plugin.settings.volume).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.volume = value;
      await this.plugin.saveAllData();
      this.plugin.timerService.soundService.play("blip");
    }));
    const soundOptions = {
      "none": "None",
      "blip": "Blip (Start)",
      "ding": "Ding (Simple)",
      "chime": "Chime (Soft)",
      "click": "Click",
      "tick": "Tick (Mechanical)",
      "tock": "Tock (Mechanical)",
      "bell": "Bell (Metallic)",
      "wood": "Woodblock",
      "gong": "Gong (Deep)",
      "digital": "Digital Watch",
      "arcade": "Arcade PowerUp",
      "alarm": "Alarm (3 Beeps)"
    };
    new import_obsidian.Setting(containerEl).setName("Work start sound").setDesc("Sound to play when a focus session starts").addDropdown((drop) => drop.addOptions(soundOptions).setValue(this.plugin.settings.soundWorkStart).onChange(async (val) => {
      this.plugin.settings.soundWorkStart = val;
      await this.plugin.saveAllData();
      this.plugin.timerService.soundService.play(val);
    }));
    new import_obsidian.Setting(containerEl).setName("Work complete sound").setDesc("Sound to play when a focus session ends").addDropdown((drop) => drop.addOptions(soundOptions).setValue(this.plugin.settings.soundWorkEnd).onChange(async (val) => {
      this.plugin.settings.soundWorkEnd = val;
      await this.plugin.saveAllData();
      this.plugin.timerService.soundService.play(val);
    }));
    new import_obsidian.Setting(containerEl).setName("Break complete sound").setDesc("Sound to play when a break ends (short or long)").addDropdown((drop) => drop.addOptions(soundOptions).setValue(this.plugin.settings.soundBreakEnd).onChange(async (val) => {
      this.plugin.settings.soundBreakEnd = val;
      await this.plugin.saveAllData();
      this.plugin.timerService.soundService.play(val);
    }));
    new import_obsidian.Setting(containerEl).setName("Pause sound").setDesc("Sound to play when timer is paused").addDropdown((drop) => drop.addOptions(soundOptions).setValue(this.plugin.settings.soundPause).onChange(async (val) => {
      this.plugin.settings.soundPause = val;
      await this.plugin.saveAllData();
      this.plugin.timerService.soundService.play(val);
    }));
    new import_obsidian.Setting(containerEl).setName("Debug").setHeading();
    let logsContainer = null;
    let logsTextArea = null;
    new import_obsidian.Setting(containerEl).setName("Enable debug logs").setDesc("When enabled, detailed logs will be visible in the console (Ctrl+Shift+I) and below").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableDebugLogs).onChange(async (value) => {
      this.plugin.settings.enableDebugLogs = value;
      await this.plugin.saveAllData();
      if (logsContainer) {
        if (value) {
          logsContainer.removeClass("pomodoro-hidden");
        } else {
          logsContainer.addClass("pomodoro-hidden");
        }
      }
    }));
    logsContainer = containerEl.createDiv({ cls: "pomodoro-debug-logs-container" });
    if (!this.plugin.settings.enableDebugLogs) {
      logsContainer.addClass("pomodoro-hidden");
    }
    const logsHeader = logsContainer.createDiv({ cls: "pomodoro-debug-logs-header" });
    logsHeader.createSpan({ text: "Debug Logs", cls: "pomodoro-debug-logs-title" });
    const logsActions = logsHeader.createDiv({ cls: "pomodoro-debug-logs-actions" });
    const refreshBtn = logsActions.createEl("button", { text: "\u{1F504} Refresh", cls: "pomodoro-debug-btn" });
    refreshBtn.onclick = () => {
      if (logsTextArea) {
        logsTextArea.value = this.plugin.debugLogger.getLogs() || "No logs yet. Perform some actions to generate logs.";
      }
    };
    const copyBtn = logsActions.createEl("button", { text: "\u{1F4CB} Copy", cls: "pomodoro-debug-btn" });
    copyBtn.onclick = () => {
      if (logsTextArea) {
        navigator.clipboard.writeText(logsTextArea.value);
        new import_obsidian.Notice("Logs copied to clipboard!");
      }
    };
    const clearBtn = logsActions.createEl("button", { text: "\u{1F5D1}\uFE0F Clear", cls: "pomodoro-debug-btn" });
    clearBtn.onclick = () => {
      this.plugin.debugLogger.clear();
      if (logsTextArea) {
        logsTextArea.value = "Logs cleared.";
      }
    };
    logsTextArea = logsContainer.createEl("textarea", {
      cls: "pomodoro-debug-logs-textarea",
      attr: {
        readonly: "true",
        rows: "10",
        placeholder: "Debug logs will appear here when actions are performed..."
      }
    });
    logsTextArea.value = this.plugin.debugLogger.getLogs() || "No logs yet. Perform some actions to generate logs.";
  }
};
var RenameModal = class extends import_obsidian.Modal {
  constructor(app, defaultName, onSubmit) {
    super(app);
    this.result = defaultName;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Rename marker" });
    new import_obsidian.Setting(contentEl).setName("New name").addText((text) => {
      text.setValue(this.result).onChange((value) => {
        this.result = value;
      });
      text.inputEl.focus();
      text.inputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          this.close();
          this.onSubmit(this.result);
        }
      });
    });
    new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Update").setCta().onClick(() => {
      this.close();
      this.onSubmit(this.result);
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
